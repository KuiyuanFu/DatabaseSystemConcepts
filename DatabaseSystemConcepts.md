​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

## 第1章 引言

- **数据库管理系统**（DataBase-Management System，DBMS）：由互相关联的**数据的集合**和一组用以访问这些数据的**程序**组成。
- **数据库**（databse）：这个数据集合。

### 1.1 数据库系统的应用

所有需要存储格式化数据的应用都可以使用数据库系统。

### 1.2 数据库系统的目标

- **文件处理系统**（file-processing system）：永久记录被存储在多个不同的文件中，编写不同的应用程序来将记录从有关文件中取出或加入到适当的文件中。

文件处理系统的弊端：

- **数据的冗余和不一致**（data redundancy and inconsistency）：同一数据在不同位置**出现多次**，同一数据的**不同副本不一致**。
- **数据访问困难**（difficulty in accessing data）：不支持一种方便高效的方式其获取所需数据。
- **数据孤立**（data isolation）：由于数据分散在不同文件，格式可能不同，检索数据很困难。
- **完整性问题**（integrity problem）：数据库中存储的值必须满足特定的**一致性约束**（consistency constraint）。
- **原子性问题**（atomicity problem）：当计算机系统发生故障，数据需要恢复到故障发生前一致的状态。操作必须是**原子的**，即要么全部发生，要么根本不发生。
- **并发访问异常**（concurrent-access anomaly）：系统允许多个用户同时更新数据，可能**导致数据不一致**。
- **安全性问题**（security problem）：需要访问控制，不是所有人都可以访问数据。



### 1.3 数据视图

数据库系统的一个主要目的是给用户提供**数据的抽象视图**。

#### 1.3.1 数据抽象

- **物理层**（physical level）：最低层次的抽象，描述数据实际上怎么存储的。详细描述复杂的底层数据结构。

- **逻辑层**（logical level）：比物理层稍高的抽象，描述数据库中存储什么数据，及这些数据间存在什么关系。逻辑层通过少量相对简单的结构描述了整个数据库，不需要知道复杂的物理层结构，称为**物理数据独立性**（physical data independence）。

- **视图层**（view level）：最高层次的抽象，只描述整个数据库的某个部分，简单，只关注需要访问的一部分。

#### 1.3.2 实例和模式

- **实例**（instance）：特定时刻存储在数据库中的信息的集合。

- **模式**（schema）：数据库的总体设计。

根据数据抽象层次，可以分为几种不同的模式：

- **物理模式**（physical schema）：在物理层描述数据库的设计。

- **逻辑模式**（logical schema）：在逻辑层描述数据库的设计。

- **子模式**（subschema）：在视图层可以有多种模式描述数据库的设计。



- **数据物理独立性**（physical data independence）：应用程序不依赖于物理模式。

#### 1.3.3 数据模型

- **数据模型**（data model）：描述数据、数据联系、数据语义及一致性约束的**概念工具的集合**，提供了一种描述物理层、逻辑层以及视图层数据库设计的方式。

数据模型可被分为四类：

- **关系模型**（relational model）：用**表的集合**表示数据和数据间的关系。

- **实体联系模型**（entity-relationship model，E-R model）：基于对现实世界的一种认识，即现实世界由一组**称为实体的基本对象**，以及这些对象之间的**联系**构成。

- **基于对象的数据模型**（object-based data model）：**对E-R模型**增加封装、方法和对象标识等概念后**的扩展**。

- **半结构化数据模型**（semistructured data model）：允许相同类型的数据项含有不同的属性集的数据定义。**可扩展标记语言**（eXtensible Markup Language，XML）用来表示半结构化数据。

### 1.4 数据库语言

- **数据定义语言**（data-definition language）：定义数据库模式。

- **数据操纵语言**（data-manipulation language）：表达数据库的查询和更新。

#### 1.4.1数据操纵语言

可以使得用户可以**访问或操纵**那些按照某种适当的**数据模型**组织起来的**数据**。

访问类型：

- 对存储在数据库中的信息进行**检索**。
- 向数据库中**插入**新的信息。
- 从数据库中**删除**信息。
- **修改**数据库中存储的信息。

两类**基本的数据操纵语言**：

- **过程化 DML**（procedural DML）：要求用户指定**需要什么数据**，以及**如何获得**这些数据。

- **声明式 DML**（declarative DML）：也称**非过程化 DML**。只要求用户指定**需要什么数据**。

通常**声明式 DML** 比过程化 DML **更易学易用**。但是需要数据库系统找出**访问数据的高效途径**。

- **查询**（query）：要求对信息进行**检索**的语句。实践中，把**查询语言**和**数据操纵语言**当作**同义词**。

#### 1.4.1数据定义语言

表达**数据库模式的一系列定义**。

- **数据存储和定义语言**（data storage and definition language）：**一系列特殊的 DDL 语句**，说明数据库系统所使用的**存储结构**和**访问方式**。定义了数据库模式的实现细节，而这些细节对用户来说通常是不可见的。

存储在数据库中的数据必须满足某些**一致性约束**。

- **域约束**（domain constraint）：每个属性对应于一个**所有可能取值构成的域**。

- **参照完整性**（referential integrity）：**一个关系**中给定**属性集**上**的取值**，**在另一关系**的某一**属性集**的**取值中出现**。

- **断言**（saaertion）：数据库需要**持续满足的某一条件**。**域约束**和**参照完整性**是**特殊的断言**。

- **授权**（authorization）：**对于不同的用户**在数据库中的不同数据值上**允许不同的访问类型**。
  - **读权限**（read authorization）：允许读取数据。
  - **插入权限**（insert authorization）：允许插入新数据。
  - **更新权限**（update authorization）：允许修改数据。
  - **删除权限**（delete authorization）：允许删除数据。

DDL 以一些指令作为输入，生成一些输出。输出放在**数据字典**（data dictionary）中，数据字典包含了**元数据**（matedata），元数据是关于数据的数据。

可以把**数据字典看作是一种特殊的表**，这个表只能由数**据库系统本身来访问和修改**。在操作实际的数据前，数据库系统先要参考数据字典。

### 1.5 关系数据库

关系数据库**基于联系模型**，使用一系列**表**来表示**数据**以及这些数据之间的**关系**。

#### 1.5.1 表

每个表有多个列，每个列有唯一的名字。

**关系模型**是**记录**的**模型**的**一个实例**。

数据库的结构是**几种固定格式的记录**。

每个**表**包含一种特定类型的**记录**。

每种**记录**类型定义固定数目的**字段或属性**。

表的**列**对应记录类型的**属性**。

#### 1.5.2 数据操纵语言

SQl查询语言是**非过程化的 DML**。

以几个表作为输入，但**总是返回一个表**。

#### 1.5.3 数据定义语言

SQL 提供了丰富的 DLL 语言，可以定义表、完整性约束、断言。

#### 1.5.4 来自应用程序的数据库访问

**SQL 不是图灵完备的**。一些计算可以用通用的程序设计语言来表达，但无法通过 SQL 来表达。

- **应用程序**（application program）：用一种**宿主语言**来编写的，执行SQL**不能表达的操作**的，与**数据库进行交互**的程序。

两种实现方式：

- **应用程序接口**：将 DML 与 DDL 语句发送给数据库，再取回结果。
- **扩展宿主语言语法**：在宿主语言的程序中嵌入 DML 调用。使用一个特殊关键字作为 DML 调用的开始，并且通过 **DML 预处理器**，将 DML 语言转化为宿主语言中的过程调用。

### 1.6 数据库设计

数据库对终端产品应用起到**支撑作用**。

数据库设计主要是**数据库模式的设计**。

#### 1.6.1 设计过程

高层的**数据模型**提供了**概念框架**，说明了数据库用户的**数据需求**，机器如何构造**数据库结构**。



- **数据需求**（data requirement）：全面刻画**预期的**数据库用户的**数据需求**。
- **概念设计**（conceptual-design）：选择一个**数据模型**，将**需求**转换成一个数据库的**概念模式**，重点描述**数据**以及它们之间的**关系**，即**元素**以及如何组织成**表**。
- **功能需求说明**（specification of functioanl requirement）：描述数据之上的**各种操作**。
- **逻辑设计**（logical-design）：将高层的**概念模式**，**映射**到要使用的数据库系统的**实现数据模型**上。
- **物理设计**（physical-design）：指定数据库的**物理特性**，包括文件组织形式及内部存储结构。

#### 1.6.3 实体-联系模型

- **实体**（entity）：现实世界中可以**区别于**其他对象的一件**事情**或者一个**物体**。
  - **属性**（attribute）：实体的属性，**实体通过属性来区分**。
  - **实体集**（entity set）：同一类型的所有实体的集合。
- **联系**（relationship）：是几个实体之间的**关联**。
  - **联系集**（relationship set）：同一类型所有联系的集合。

- **统一建模语言**（Unified Modeling Language，UML）：图形化表示数据库的总体逻辑结构的一种**方法**。**实体集**用**矩形框**表示，实体名在头部，属性名列在下面；**联系集**用链接一对相关实体集的**菱形**表示，联系名放在菱形内部。

  - **映射基数**（mapping cardinality）：表示通过某个联系集能与一实体进行关联的**实体数目**。

  

#### 1.6.4 规范化

- **规范化**（normalization）：生成一个关系模式集合，使其**无冗余**，**容易检索**。设计一种符合适当范式的模型。
  - **函数依赖**（functional dependency）：一种规范化的方法。

### 1.7 数据存储和查询

数据库系统可分为**存储管理器**和**查询处理**。

#### 1.7.1 存储管理器

负责在数据库中存储的**底层数据结构**与**应用程序**以及向系统**提交的查询**之间**提供接口的部件**。

将DML语言**翻译**为底层文件系统命令。

- **权限及完整性管理器**（authorization and integrity manager）：检测权限及完整性约束。
- **事务管理器**（transaction manager）：保证数据库一致性，并发无冲突。
- **文件管理器**（file manager）：管理磁盘空间的分配，存储信息的数据结构。
- **缓冲区管理器**（buffer manager）：从磁盘缓冲数据，关键部分。
- **数据文件**（data files）：存储数据库自身。
- **数据字典**（data dictionary）：存储关于数据库结构的元数据，尤其是数据库模式。
- **索引**（index）：提供对数据项的快速访问。



#### 1.7.2 查询处理器

- **DDL 解释器**（DDL interpreter）：解释 DDL 语句并将这些定义记录在数据字典中。

- **DML 编译器**（DML compiler）：将查询语句中DML语句翻译为一个执行方案，包括一系列低级指令。

- **查询执行引擎**（query evaluation engine）：执行由 DML 编译器翻译出的低级指令。

  

### 1.8 事务管理

- **事务**（transaction）：完成单一逻辑功能的操作集合，满足原子性，一致性。
  - **原子性**（atomicity）：要么完成，要么不发生。
  - **一致性**（consistency）：满足一定约束。
  - **持久性**（durability）：完成后，要持久保持新值。
- **事务管理器**（transaction manager）：管理事务。
  - **恢复管理器**（recovery manager）：负责原子性和持久性。
    - **故障恢复**（failure recovery）：当事务执行失败时，将数据库恢复到故障发生之前。
  - **并发控制管理器**（concurrency-control manager）：控制并发事务之间的相互影响。

### 1.9 数据库体系结构

整体调用结构：

- **用户**。

- **应用**。

- **查询管理器**。

- **存储管理器**。

- **磁盘存储**。

  

两个层次：

- **客户机**（client）：通过查询语言调用服务器上的数据库系统功能。

- **服务器**（server）：提供数据库服务。

### 1.10 数据挖掘与信息检索

- **数据挖掘**（data mining）：半自动分析大型数据库，从中找到有用的模式的过程。

- **信息检索**（information retrieval）：查询非结构化的文本数据。

### 1.11 特种数据库

处理特殊应用领域的数据库系统，包括**基于对象的数据模型**和**半结构化数据模型**。



#### 1.11.1 基于对象的数据模型

- **基于对象的数据模型**（object-based data model）：由于面向对象程序设计占统治地位，导致其发展。可以看作 E-R 模型的扩展，增加封装、方法和对象标识。
  - **对象-关系模型**（object-relation data model）：将**基于对象的数据模型**和**关系数据模型**特点结合在一起的数据模型。

#### 1.11.2 半结构化数据模型

**半结构化数据模型**允许**相同类型的数据**有**不同的属性集的数据说明**。

XML 语言支持嵌套结构，很有效。

### 1.12 数据库用户和管理员

#### 1.12.1 数据库用户和用户界面

根据数据库用户的水平及交互方式，可分为：

- **无经验的用户**（naive user）：默认用户，激活应用程序进行交互。
- **应用程序员**（application programmer）：编写应用程序的计算机专业人员。
  - **快速应用开发**（Rapid Application Development，RAD）：专用工具，使程序员可以**尽量少编写程序**就可以构造出**表格**和**报表**的工具。
- **老练的用户**（sophisticated user）：直接使用数据库查询语言或分析软件。
- **专门的用户**（specialized user）：编写数据库应用本身的富有经验的用户。

#### 1.12.2 数据库管理员

- **数据库管理员**（DataBase Administrator，DBA）：对系统进行集中控制的人。

  - **模式定义**（schema definition）：通过DDL定义来创建最初的数据库模式。
  - **存储结构及存取方法定义**（storage structure and access-method definition）。
  - **模式及物理组织的修改**（schema and phsical-organization modification）：修改，以反应机构需求的变化，或提高性能。
  - **数据库访问授权**（granting of authorization for data access）。
  - **日常维护**（routine maintenance）：
    - **定期备份**。
    - **磁盘空间管理**。
    - **性能监控**。

## 第一部分 关系数据库

关系模型是一种**简单的数据模型**，广泛使用，利用**表的集合**来表示数据和数据间的关系。在**逻辑层**和**视图层**描述数据，而不用关系物理结构。

## 第2章 关系模型介绍

### 2.1 关系数据库的结构

- **表**（table）：关系数据库的基本单元，关系数据库由**表的集合**构成。每个表都唯一的名字。

  - **列首**：列的名字，表明列存储的信息含义。
  - **行**：每一行代表了一组值之间的一种联系，**表是这种联系的集合**。
  - **关系**（relation）：指代**表**。
  - **元组**（tuple）：数学中的概念，是一组值的序列，指代**一行**。

  - **属性**（attribute）：指代表中的**列**。

- **关系实例**（relation instance）：一个关系的特定实例，也就是**包含一组特定的行的集合**。

- **域**（domain）：对于关系中的每个属性，都有**一个允许取值的集合**。

- **原子的**（atomic）：属性的域中的元素被看作是**不可再分的单元**，那么域是原子的。要求所有域都是原子的。

- **空值**（null）：表示**值未知或不存在**，尽可能不使用空值。

### 2.2 数据库模式

- **数据库模式**（database schema）：数据库的逻辑设计。

- **数据库实例**（database instance）：给定时刻数据库中的数据的一个快照。

- **关系模式**（relation schema）：对应程序设计语言中**变量类型定义**，而**关系**对应**变量**。关系模式由**属性序列**及各属性**对应域**组成。
- **关系实例**（relation instance）：对应程序设计语言中**变量的值**。关系被更新时，通常是实例被更新，而不是改变模式。

### 2.3 码

区分给定关系中不同元组的方法，用他们的属性来表明，唯一区分元组。一个关系上没有两个元组在所有属性上的取值都相同。

- **超码**（super key）：一个或多个属性的集合，这些属性的组合可以在一个关系中**唯一地标识**一个元组。超码的任何一个**超集也是超码**。

- **候选码**（candidate key）：如果一个超码的任何**真子集都不是超码**，那么这个超码就是候选码。候选码就是这几个属性中能唯一标识元组的最小属性集。

- **主码**（primary key）：被数据库设计者选中的，主要用来区分不同元组的候选码。选择几乎不会改变元素值的属性。

- **外码**（foreign key）：如果一个关系模型的属性包含另一个关系模式的主码，那么这个属性在前一个关系模式上称作外码。
  - **参照关系**（referencing relation）：前一个关系模型。
  - **被参照关系**（referenced relation）：后一个关系模型。
  - **参照完整性约束**（referential integrity constraint）：前一个关系模型的外码值，必须在后一个关系模型的主码值中出现过。

### 2.4 模式图

一个含有**主码**和**外码依赖**的数据库模式可以用**模式图**来表示。

- **模式图**（schema diagram）：每一个关系用一个矩形表示，名字在最上方，属性在下方，主码加下划线，从外码属性指向主码属性。

### 2.5 关系查询语言

- **查询语言**（query language）：用户用来从数据库中请求获得信息的语言。

  - **过程化语言**（procedural language）：用户直接指导系统执行一系列操作。如**关系代数**。

  - **非过程话语言**（nonprocedural language）：只描述所需信息，不用指定具体过程。如**元组关系演算**和**域关系演算**。

  

### 2.6 关系运算

过程化语言提过一组运算，施加于单个或一对关系上，得到一个输出关系。所以可以组合多个元素。

关系代数：

| 名字     |   符号   |                      示例                       |                           说明                           |
| -------- | :------: | :---------------------------------------------: | :------------------------------------------------------: |
| 选择     | $\sigma$ |     $\sigma_{salary >= 85000}(instructor) $     |                返回输入关系中满足谓词的行                |
| 投影     |  $\Pi$   |          $\Pi_{ID,salary}(instructor)$          |          对输入关系的所有行输出特定的属性，去重          |
| 自然连接 | $\Join$  |          $instructor \Join department$          | 从两个输入关系中输出相同名字的所有属性上取值相同的元组对 |
| 笛卡儿积 | $\times$ |         $instructor \times department$          |              从两个输入关系中输出所有元组对              |
| 并       |  $\cup$  | $\Pi_{name}(instructor)\cup\Pi_{name}(student)$ |                输出两个输入关系中元组的并                |



## 第3章 SQL

### 3.1 SQL 查询语言概览

SQL 语言部分：

- **数据定义语言**（Data-Defination Language，DDL）：提供定义、删除及修改关系模型的命令。

- **数据操纵语言**（Data-Manipulation Language，DML）：提供从数据库中查询信息，记忆在数据空中插入、删除及修改元组的命令。

- **完整性**（integrity）：DDL 中包含定义完整性约束的命令。

- **视图定义**（view definition）：DDL 包括当以视图的命令。

- **事务控制**（transaction control）：定义事务的开始和结束的命令。

- **嵌入式SQL和动态SQL**（embedded SQL and dynamic SQL）：如何嵌入到通用编程语言中。

- **授权**（authorization）：DDL 包括定义对关系和视图的访问权限的命令。


### 3.2 SQL 数据定义

SQL DDL 可以定义**关系**及其**信息**：

- 每个关系的模式。
- 属性的取值类型。
- 完整性约束。
- 每个关系维护的索引集合。
- 每个关系的安全性和权限信息。
- 每个关系在磁盘上的物理存储结构。

#### 3.2.1 基本类型

固有类型：

- **char(n)**：固定长度字符串，全称 **character**。

- **varchar(n)**：可变长度字符串，指最大长度，全称 **character varying**。

- **int**：整形，与机器相关，全称 **integer**。

- **smallint**：小整数类型，与机器相关。

- **numeric(p,d)**：定点数，p位，其中 q位小数。

- **real**：浮点数。

- **double precision**：双精度浮点数。
- **float(n)**：浮点数，精度至少为 n。

#### 3.2.2 基本模式定义

使用 `create table` 命令定义 SQL 关系，通用格式：

````
create table r
	(A_1 D_1, 
	A_2 D_2, 	
	...,
	<integrity constraint_1>,
	<integrity constraint_2>,
	...,
	);
````

- `r`：关系名
- `A_i`：属性名
- `D_i`：对应关系的属性

多种完整性约束，如：

- `primary key (A_i, ...)`：主键
- `foreign key (A_i, ...) references : r_i `：外键
- `A_i not null `：非空

### 3.3 SQL 查询的基本结构

使用 `select`、`from` 和 `where` 子句构成。

`select ... from ... where ...`

过程：

-  为`from` 的关系产生笛卡尔积。
- 对结果应用 `where` 指定的谓词。
- 输出 `select` 中指定的属性。



要点：

- 得到结果默认是有重复项的，`select distinct ...` 去重。

- 使用 `r_i.A_i` 来指定特定关系中的属性，防止使用多个关系时，属性名重复导致的混淆。
- `whree` 子句就是限制使用多个关系时，生成笛卡尔积的大小。

### 3.4 附加的基本运算

- **自然连接**（natural join）的得到两个关系中相同属性名上属性也相同的笛卡尔积。`from r_i natural join r_j`。`r_i join r_j using (A_i, ...)`。
- 重命名 `r_i as r_n`，新的名字称作**相关名称**（correlation name）、**表别名**（table alias）、**相关变量**（correlation variable）或 **元组变量**（tuple variable）。
- 使用一对单引号表示字符串，使用**两个单引号**表示一个字符串中的**单引号**。
- 在 `like` 条件子句中，使用 `%` 表示任意多个字符，而 `_` 表示任意一个字符，使用额外的 `escape` 子句定义转义字符，以匹配特殊字符。`like 'ab\%cd%' escape '\'` 匹配以`ab%cd` 开头的所有字符串。
- `*`可表示所有属性。
- `order by` 子句**排列**元组的顺序，默认升序，`desc` 表示降序，`ase`表示升序。`order by A_i desc, A_j ase`。
- `A_i between n_1 and n_2` 比较属性值是否在两者之间。

### 3.5 集合运算

- `union`，`intersect` ，`except`  对应集合中的**并**，**交**，**差**运算。会自动去重。
- `(select A_i from r_i where A_i = n_i ) union (select A_j from r_j where A_j = n_j )` 。

### 3.6 空值

- 涉及到 `null` 的任何操作，得到的结果都是 `unknown`，既不是 `is null` ，也不是 `not is null`。是**第三个逻辑值**。
- 如果一个涉及`unknown`的逻辑表达式，不使用`unknown`部分就可以得到确定的逻辑值，结果就为这个值，否则结果为 `unknown`。

### 3.7 聚合函数

- `avg`，`min`，`max`，`sum`，`count`
- `select avg(A_i) as A_n from r_i group by A_j having A_j > 0;  ` ，`group by` 是分组依据，而 `having` 是只提取符合条件的分组。
- 聚合时不计算 `null` 的值。

过程：

- `from` 计算笛卡尔积
- `where` 过滤
- `group by` 分组
- `having` 过滤分组
- `select` 提取

### 3.8 嵌套子查询

可以使用嵌套子查询，代替任何**关系**可以出现的位置。

- 集合成员资格：`where A_i in r_i` ，条件为 `A_i` 在 `r_i` 中的元组。
- 集合的比较：`where A_i > some r_i`，条件为，`A_i`与`r_i` 中的任意元组满足条件。`where A_i > all r_i`，条件为，`A_i`与`r_i` 中的所有元组满足条件。
- 空关系测试：`where exists (r_i)`，条件为 `r_i` 不为空。
  - **相关子查询**（correlated subquery）：使用了来自**外层查询相关名称**的子查询。
- 重复元组存在性测试：`where unique (r_i)`，条件为 `r_i` 中不存在重复元组。
- 关系重命名：`(select A_i from r_i ) as r_j (A_j)`，将一个查询结果，重命名成一个关系，方便使用。
- 临时关系：`with  r_j (A_j) as (select A_i from r_i ) select r_j.A_j from r_k where r_k.A_j = r_j.A_j  `，是在 `where`语句中写子查询的等价形式，但是更直观明了，`with`中的`as` 是将**后面关系**重命名为**前面的名称**。 
- 标量子查询：`where A_i = (select count(*) from r_i)`，可以在使用标量的地方使用这个查询，需要保证只有一个返回值。

### 3.9 数据库的修改

- 删除：`delete from r_i where (); `，每次只能删除一个关系中的元组。

- 插入：`insert into r_i (A_i, ...) values (v_i, ...);`，在指定关系中，插入指定属性的值。

- 更新：`update r_i set A_i = v_i where () `，或者使用 `case` ，即 `update r_i set A_i = case when() then () ... else () where ()`，每一个 `when` 对应一个 `then` ，将 `then` 的结果更新给 `A_i` 。

  

## 第4章 中级 SQL

### 4.1 连接表达式

- `select * form r_i join r_j on r_i.A_i = r_j.a_j;` ，使用 `on` 来指定自然连接的条件，此时等价于 `where ` 语句。可以同时使用 `on` 语句表示连接条件，`where` 语句表示其他的过滤条件，更清晰。
-  `select * form r_i left outer join r_j;` ，外连接将**保留未出现匹配的元组**，即 `left outer join` 中，即使左侧的关系中，有的元组并没有与右侧元组匹配，但是还会出现在结果中，此元组中的右侧的属性为 `null`。`right outer join` 将保留所有右侧关系。`full outer join` 保留所有关系。即外连接，保证了关系中所有元组都会出现在结果中，而**常规连接**是**内连接**，不匹配的元组不会出现在结果中。
- `on` 语句是在**连接期间**起作用的，所以可以保证在外连接时，左右两侧都是有值的，而不是连接后，补的`null`值。

### 4.2 视图

- **视图**（view）：不是逻辑模型的一部分，但作为**虚关系**对用户可见的关系。由于权限等原因，不能向用户展示关系中的所有属性，可以通过一个查询将逻辑模型中的关系映射到一个新的虚关系中，这个关系并不储存属性，访问时，进行查询，保证一致性。
- `create view v(A_i,...) as  <query expression>;` 将查询语句保存为视图。可以显式指定属性名，也可以省略，直接使用查询结果的属性名。但是结果属性是没有名字的，就需要显式指定了。
- `select A_i from v; `，像使用关系一样使用视图。
- **物化视图**（materialized view）：存储视图关系，保证定义视图的实际关系改变时，视图也随之改变。适用于查询过程复杂，而结果简单的视图。需要使用数据库系统提供的扩展工具，没有标准工具。
  - **视图维护**（view maintenance）：保持物化视图一直在最新状态的过程。
- **可更新的**（updatable）：一般情况是不允许向视图更新元组的，因为存在连接、空属性、无属性的情况。只有满足特定条件才是可更新的。插入的元组，必须满足 `where` 子句的条件。
  - `from` 子句只有一个关系。
  - `select` 子句中只包含关系的属性，不包含表达式。
  - 没有出现在 `select` 中的属性是可以包含 `null` 的。
  - 查询中不包含 `group by`，`having` 子句。

### 4.3 事务

- **事务**（transaction）：由查询和更新语句的序列组成。当一条 SQL 语句开始执行时，就**隐式**开始了一个事务。`Commit work` 会提交当前事务，并持久保存；`Rollback work` 会回滚当前事务，撤销所有更新。大部分数据库，将一个SQL 语句自成一个事务，执行后直接提交，关闭自动提交依赖系统实现。SQL:1999 标准中允许多条 SQL 语句包含在 `begin atomic ... end `中，形成一个事务，但是并不是所有系统都实现了。

  

### 4.4 完整性约束

- `create table <constraint> ` 和`alter table <table name> add <constraint>` 是添加完整行约束的两种方式。
- `not null` 非空约束，禁止插入空值。主码默认非空。
- `unique` 唯一约束，可以使用 `unique (A_i,...)` 约束多个属性，使其称为一个候选码。
- `check (P)` ，满足谓词 `P` 。
- `foreign key(A_i) reference r_i` 参照完整性，**外键属性的值**必须在**其为主键的关系**值中出现。当违反参照完整性时，可以设置不拒绝，而是额外执行更多操作。`on delete cascade`，级联删除。`on update cascade` 级联更新。
- ` <constraint> initially deferred` 子句，使约束可以延迟检查。默认情况是立即检查。但在事务中，可能临时违反约束，但是之后会修正，可以在事务中添加 `set constraints <constraint list> deferred` ，指定需要延迟检查的约束，会在事务语句之后完后进行检查。
- `create assertion <assertion name > check <predicate>;` 通过创建断言，制定复杂的约束。



### 4.5 SQL 的数据类型与模式

- `data` 日历日期，年月日。
- `time` 一天的时间，小时分钟秒。
- `timestamp(p)` 时间戳，指定秒后的位数。
- `default n` 设置默认值为 `n`。
- `create index <index name> on <table name > (< attribute name list>)`  在指定的属性上创建索引。若多个属性，会依次作为索引条件。
- `clob ` `blob` 分别是**字符**和**二进制**的大对象。
- `create type <new type name> as <type> final ; `将类型定义定义为一个新类型，这样可以指代明确。
- `create domain <domain name > <type> constraint <constraint name > check ( < P > )`;，创建一个域，可以作为属性类型。
- `create table <table name > as <table>;` 创建一个同结构的表。`create table <table name > as < select ...> with data;` 连数据一起复制。
- **目录**（catalog）是第一层，即文件。**模式**（schema），第二层。**关系**、**视图**等为第三层。定位一个表，为 `<catalog>.<schema>.<relation>`。                   

### 4.6 授权

- `select`、`insert`、`update`、`delete`四种权限。`all privileges` 为所有权限。
- `grant <privileges list > on <relation>(attribute list) to <user list>`。
- `revoke <privileges list > on <relation>(attribute list) to <user list>`。
- `create role <role name >; grant <privileges list > on <relation>(attribute list) to <role name >;  grant  <role name > to  <user list>;` 使用角色来分配权限。
- 创建视图时，由于使用视图需要进行查询，所以权限为创建者的权限。
- `grant reference (attribute list)  on <relation> to <user list> ` 获得参照权限，因为修改原关系时，需要根据参照完整性，检查是否有外键属性使用了这个值。
- `grant <privileges list > on <relation>(attribute list) to <user list> with grant option` 。`with grant option`允许用户转移这个权限。
